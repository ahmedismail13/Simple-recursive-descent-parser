/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ScanParse;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileSystemView;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Ahmed
 */
public class ScanParse extends javax.swing.JFrame {

    final String[] SYMBOLS = {";","(",")","{","}","[","]",".","!"};
    final String[] RESERVED_WORDS = {"if","else","while","for","public","class","return","static","true","fasle","this","new"};
    final String[] DATA_TYPE = {"int","boolean","void","String"};
    final String[] BINARY_OP = {"<",">","=","+","-","*","/","&&"};
    ArrayList<Token> tokens = new ArrayList<>();
    
    //typeCheck function is used to determine the tokenClass attribute in each token.
    private String typeCheck(String lexeme)
    {
        String type ="Invaild Token";
        for(int i =0; i< RESERVED_WORDS.length;i++)
        {
            if(lexeme.equals(RESERVED_WORDS[i]))
                type = "Reserved word";
        }
        for(int i =0; i< DATA_TYPE.length;i++)
        {
            if(lexeme.equals(DATA_TYPE[i]))
                type = "Data type";
        }
        for(int i =0; i< SYMBOLS.length;i++)
        {
            if(lexeme.equals(SYMBOLS[i]))
                type = "Symbol";
        }
        for(int i=0;i<BINARY_OP.length;i++)
        {
            if(lexeme.equals(BINARY_OP[i]))
                type = "Binary operator";
        }
        boolean flag = true;
        for(int i=0;i<lexeme.length();i++)
        {
            switch(lexeme.charAt(i))
            {
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case '0':
                    break;
                default:
                    flag = false;
                    break;
            }
        }
        if(flag)
        {
            type = "Integer literal";
        }
        if(type == "Invaild Token")
        {
            if(lexeme.charAt(0) == '1' || lexeme.charAt(0) == '2' || lexeme.charAt(0) == '3' || 
               lexeme.charAt(0) == '4' || lexeme.charAt(0) == '5' || lexeme.charAt(0) == '6' || 
               lexeme.charAt(0) == '7' || lexeme.charAt(0) == '8' || lexeme.charAt(0) == '9' || 
               lexeme.charAt(0) == '0' )
                type = "Invaild Token";
            else
                type = "Identifier";
        }
        return type;
    }
    
    public ScanParse() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTable1.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Lexeme", "Class", "Line number"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jLabel1.setText(" Original Code:");

        jLabel2.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jLabel2.setText(" Lexemes table:");

        jButton1.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jButton1.setText("Upload code");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jButton2.setText("Analyse tokens");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jButton3.setText("Parse code");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jLabel3.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jLabel3.setText(" Parsing status:");

        jLabel4.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane2.setViewportView(jTextArea1);

        jLabel5.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jLabel5.setText(" Error status:");

        jLabel6.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 379, Short.MAX_VALUE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 375, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addGap(18, 18, 18)
                                .addComponent(jLabel4))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                        .addComponent(jLabel5)
                                        .addGap(18, 18, 18)
                                        .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                    .addComponent(jButton1))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jButton2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jButton3)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(jButton2)
                    .addComponent(jButton3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addGap(0, 3, Short.MAX_VALUE))
                    .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        JFileChooser j = new JFileChooser(FileSystemView.getFileSystemView().getHomeDirectory());
        j.showSaveDialog(null);
        String path = j.getSelectedFile().getPath();
        try {
            byte[] encoded = Files.readAllBytes(Paths.get(path));
            String code = new String(encoded,"UTF-8");
            jTextArea1.setText(code);
        } catch (IOException ex) {
            Logger.getLogger(ScanParse.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        Parser p = new Parser(tokens);
        if(p.isParsed())
        {
            jLabel4.setText("Code Parsed Successfully!");
            jLabel6.setText("No errors!");
        }
        else
        {
            jLabel4.setText("Code Parsed Unsuccessfully!");
            jLabel6.setText(p.getError());
        }
            
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        String code = jTextArea1.getText();
        //Arraylist of tokens to hold all the values we are scanning
        
        int lineCount = 1;
        //Splitting the code by separating words who are preceded or followed by a space character.
        String[] t = code.split(" ");
        //Removing tabs, carriage returns and new lines 
        //in addition to puting the lexemes splited into tokens and adjusting the line number of each lexeme.
        for(int i=0;i<t.length;i++)
        {
            for(int j=0;j<t[i].length();j++)
            {
                if(t[i].charAt(j) == '\r' || t[i].charAt(j) == '\t')
                {
                    StringBuilder sb = new StringBuilder(t[i]);
                    t[i] = sb.deleteCharAt(j).toString();
                    j=-1;
                }
            }
            if(t[i] == "")
                continue;
            
            for(int j=0;j<t[i].length();j++)
            {
                if(t[i].charAt(j) == '\n')
                {
                    if(t[i].length()==1)
                    {
                        lineCount++;
                    }
                    else if(j==0)
                    {
                        lineCount++;
                        t[i] = t[i].substring(1);
                        j--;
                    }
                    else
                    {
                        if(j==t[i].length()-1)
                        {
                            t[i]=t[i].substring(0, t[i].length()-1);
                            tokens.add(new Token(t[i],lineCount));
                            lineCount++;
                        }
                        else
                        {
                            tokens.add(new Token(t[i].substring(0, j),lineCount));
                            lineCount++;
                            t[i]=t[i].substring(j+1,t[i].length());
                            j=-1;
                        }
                    }
                }
                else if(t[i].charAt(j) != '\n' && j==t[i].length()-1)
                {
                    tokens.add(new Token(t[i],lineCount));
                }
            }
            
        }
        //#Section 2
        //This loop separates all the symbols from the words and add them to the arraylist with the same order of the program
        for(int i =0;i<tokens.size();i++)
        {
            for(int j=0;j<tokens.get(i).getLexeme().length();j++)
            {
                if(     tokens.get(i).getLexeme().charAt(j) == '(' || tokens.get(i).getLexeme().charAt(j) == ')'
                        || tokens.get(i).getLexeme().charAt(j) == '}' || tokens.get(i).getLexeme().charAt(j) == '{'
                        || tokens.get(i).getLexeme().charAt(j) == '[' || tokens.get(i).getLexeme().charAt(j) == ']'
                        || tokens.get(i).getLexeme().charAt(j) == '<' || tokens.get(i).getLexeme().charAt(j) == '='
                        || tokens.get(i).getLexeme().charAt(j) == '>' || tokens.get(i).getLexeme().charAt(j) == '+'
                        || tokens.get(i).getLexeme().charAt(j) == '*' || tokens.get(i).getLexeme().charAt(j) == '-' 
                        || tokens.get(i).getLexeme().charAt(j) == '/' || tokens.get(i).getLexeme().charAt(j) == ';' 
                        || tokens.get(i).getLexeme().charAt(j) == '.' || tokens.get(i).getLexeme().charAt(j) == '!'
                        || tokens.get(i).getLexeme().charAt(j) == ',' || tokens.get(i).getLexeme().charAt(j) == '&'
                        || tokens.get(i).getLexeme().charAt(j) == '|' || tokens.get(i).getLexeme().charAt(j) == '\\')
                {
                    if(tokens.get(i).getLexeme().length() == 1)
                    {
                        continue;
                    }
                    if(j ==0)
                    {
                        String symbol = tokens.get(i).getLexeme().substring(0,1);
                        String a = tokens.get(i).getLexeme().substring(1);
                        
                        Token t1 = new Token(a, tokens.get(i).getLine());
                        Token t2 = new Token(symbol, tokens.get(i).getLine());
                        tokens.remove(i);
                        tokens.add(i,t2);
                        tokens.add(++i,t1);
                        j--;
                        
                    }
                    else if(j == tokens.get(i).getLexeme().length()-1)
                    {
                        String a = tokens.get(i).getLexeme().substring(0, j);
                        String symbol = tokens.get(i).getLexeme().substring(j);
                        
                        Token t1 = new Token(a, tokens.get(i).getLine());
                        Token t2 = new Token(symbol, tokens.get(i).getLine());
                        tokens.remove(i);
                        tokens.add(i,t1);
                        tokens.add(++i,t2);
                        j=-1;
                    }
                    else
                    {
                        String a = tokens.get(i).getLexeme().substring(0, j);
                        String symbol = tokens.get(i).getLexeme().substring(j,j+1);
                        String b = tokens.get(i).getLexeme().substring(j+1);
                        
                        Token t1 = new Token(a, tokens.get(i).getLine());
                        Token t2 = new Token(symbol, tokens.get(i).getLine());
                        Token t3 = new Token(b, tokens.get(i).getLine());
                        
                        tokens.remove(i);
                        tokens.add(i,t1);
                        tokens.add(++i,t2);
                        tokens.add(++i,t3);
                        j=-1;                  
                    }
                    
                }
            }
        }
        
        //#Section 3
        //Checking for Binary operators and comments, in addition to merging the lexemes
        for(int i=0;i<tokens.size()-1;i++)
        {
            if(tokens.get(i).getLexeme().equals("&"))
            {
               if(tokens.get(i+1).getLexeme().equals("&") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
               {
                   tokens.get(i).setLexeme("&&");
                   tokens.get(i).setTokenClass("Binary operator");
                   tokens.remove(i+1);
               }
            }
            if(tokens.get(i).getLexeme().equals("/"))
            {
                if(tokens.get(i+1).getLexeme().equals("/") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
                {
                    tokens.get(i).setLexeme("//");
                    tokens.get(i).setTokenClass("Single comment");
                    tokens.remove(i+1);
                }
                else if(tokens.get(i+1).getLexeme().equals("*") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
                {
                    tokens.get(i).setLexeme("/*");
                    tokens.get(i).setTokenClass("Multi-comment begin");
                    tokens.remove(i+1);
                }
                else if(tokens.get(i-1).getLexeme().equals("*") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
                {
                    tokens.get(i).setLexeme("*/");
                    tokens.get(i).setTokenClass("Multi-comment end");
                    tokens.remove(i-1);
                }
            }
            if(tokens.get(i).getLexeme().equals("+"))
            {
               if(tokens.get(i+1).getLexeme().equals("+") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
               {
                   tokens.get(i).setLexeme("++");
                   tokens.get(i).setTokenClass("Binary operator");
                   tokens.remove(i+1);
               }
            }
            if(tokens.get(i).getLexeme().equals("-"))
            {
               if(tokens.get(i+1).getLexeme().equals("-") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
               {
                   tokens.get(i).setLexeme("--");
                   tokens.get(i).setTokenClass("Binary operator");
                   tokens.remove(i+1);
               }
            }
            if(tokens.get(i).getLexeme().equals("|"))
            {
               if(tokens.get(i+1).getLexeme().equals("|") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
               {
                   tokens.get(i).setLexeme("||");
                   tokens.get(i).setTokenClass("Binary operator");
                   tokens.remove(i+1);
               }
            }
            if(tokens.get(i).getLexeme().equals("="))
            {
               if(tokens.get(i+1).getLexeme().equals("=") && tokens.get(i+1).getLine() == tokens.get(i).getLine())
               {
                   tokens.get(i).setLexeme("==");
                   tokens.get(i).setTokenClass("Binary operator");
                   tokens.remove(i+1);
               }
            }
            
        }
        //#Section 4
        //Removing the commented tokens
        for(int i=0;i<tokens.size();i++)
        {
            if(tokens.get(i).getLexeme().equals("//"))
            {
                int line = tokens.get(i).getLine();
                while(line == tokens.get(i).getLine())
                {
                    tokens.remove(i);
                }
            }
            if(tokens.get(i).getLexeme().equals("/*"))
            {
                while(!tokens.get(i).getLexeme().equals("*/"))
                {
                    tokens.remove(i);
                }
                tokens.remove(i);
            }
        }
        //#Section 5
        //classifier function
        for(int i=0;i<tokens.size();i++)
        {
            String type = typeCheck(tokens.get(i).getLexeme());
            tokens.get(i).setTokenClass(type);
        }
        DefaultTableModel model = (DefaultTableModel) jTable1.getModel();
        for(Token i:tokens)
        {
            model.addRow(new Object[]{i.getLexeme(),i.getTokenClass(),i.getLine()} );
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ScanParse.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ScanParse.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ScanParse.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ScanParse.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ScanParse().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
}
